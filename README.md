# Наибольшая общая подпоследовательность

Найти наибольшую общую подпоследовательность двух списков. Максимальная длина списка **10³**. Пример: наибольшая подпоследовательность последовательностей `[0 5 3 9 3 3 8 4 2 5]` и `[9 0 7 6 5 0 3 7 1 0]` является последовательность `[0 5 3]`. Реализовать алгоритм динамического программирования (смотрите [Википедию](https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B8%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B0%D1%8F_%D0%BE%D0%B1%D1%89%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C) или [Хабр](https://habr.com/ru/post/142825/)). Проверить правильность работы алгоритма прямым перебором.

## Задание

В файле `main.py` нужно реализовать две функции:
+ `lcs_bf` - находит наибольшую общую подпоследовательность полным перебором,
+ `lcs` - делает то же самое, только используя динамическое программирование.

Обе функции:
+ Принимают два целочисленных массива numpy - две исходные последовательности,
+ Возвращают целочисленный массив numpy - найденная наибольшая общая подпоследовательность.

Функция `lcs` должна иметь сложность по времени и памяти не больше, чем **O(N\*M)**, где **N** и **M** - размеры входных массивов.

## Тестирование

Запустить автоматические тесты можно так:

```bash
python -m pytest -sv -k lcs_bf # тестируем полный перебор
python -m pytest -sv -k lcs # тестируем динамическое программирование
```
